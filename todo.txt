
 + debug register writes ruin everything, save written value somewhere and show it when read
 + reading __kvm_hyp_vector from el1 breaks everything, set watchpoint on over-written instruction

!! vectors must be aligned !!

 + overwrite target for el1_sync to physical address of handle_trap_el1
 + trap accesses to mdcr_el2 as well


 switch (x0) {
     case KVMRK_CALL_HYP:
         ((void (*)(void)) x1)();
         break;
     // case KVMRK_RESET_VECTORS:
     //     asm volatile("ldr x5, =__hyp_stub_vectors\n\t");
     //     asm volatile("msr vbar_el2, x5\n\t");
     //     break;
 }


 SYM_CODE_START_LOCAL(handle_trap_el1)
 	cmp 	x0, #KVMRK_CALL_HYP
 	b.ne 	1f
 	br		x1
 	eret
 1:
 	cmp     x0, #KVMRK_CRASH_EVERYTHING
 	b.ne	1f
 	add 	x0, xzr, xzr
 	ldr 	x0, [x0]
 	eret
 2:
 	eret
 SYM_CODE_END(handle_trap_el1)




 /*
 x10 *hopefully* wont get clobbered by HVC_RESET_VECTORS
 see: https://elixir.bootlin.com/linux/latest/source/arch/arm64/kernel/hyp-stub.S#L200
 */
 SYM_FUNC_START(kvmrk_replace_vbar_el2)
     add     x19, xzr, x0
     mov     x0, #HVC_RESET_VECTORS
     hvc     #0

     mov     x0, #HVC_SET_VECTORS
     add     x1, xzr, x19
     hvc     #0
     ret
 SYM_FUNC_END(kvmrk_replace_vbar_el2)



 DO ON EACH CPU


 SYM_FUNC_START(kvmrk_crash_everything)
     mov     x0, #KVMRK_CRASH_EVERYTHING
     hvc     #0
     ret
 SYM_FUNC_END(kvmrk_crash_everything)
